<h2 id="undecidability">Undecidability</h2>
<h3 id="Codes for TMs">Codes for TMs</h3>
<p>We can encode TMs as binary strings (or integers). Assume:</p>
<ul>
<li><p>States <span
class="math inline">\(q_1,q_2,\ldots,q_{r}\)</span>.</p></li>
<li><p>Tape symbols <span
class="math inline">\(X_1,X_2,\ldots,X_{s}\)</span>.</p></li>
<li><p>Directions <span class="math inline">\(D_1,D_2\)</span>.</p></li>
</ul>
<p>Encode <span class="math inline">\(\delta\left( q_{i},X_{j} \right)
=\left( q_{k},X_{l},D_{m} \right)\)</span> as <span
class="math inline">\(C=0^{i}1 0^{j}1 0^{k}1 0^{l}1 0^{m}\)</span>. Then
encode all transitions as <span class="math inline">\(w=C_1 11 C_2 11
C_3 11\ldots C_{n-1} 11 C_{n}\)</span>. Then <span
class="math inline">\(\overline{1w}\)</span> can be seen as an integer
<span class="math inline">\(i\)</span> in binary, call <span
class="math inline">\(w\)</span> the <span
class="math inline">\(i\)</span>th string <span
class="math inline">\(w_{i}\)</span>. In case a code is invalid we
assign it to the TM that automatically rejects.</p>
<div class="definition">
<p>(Diagonalization Language) <span class="math inline">\(L_{d}=\{w_{i}\
|\ w_{i}\notin L\left( M_{i} \right) \}\)</span>.</p>
</div>
<div class="theorem">
<p>(Diagonalization Language) <span class="math inline">\(L_{d}\)</span>
is not in RE.</p>
</div>
<div class="proof">
<p><em>Proof.</em> (Diagonalization Language) Assume there is a TM <span
class="math inline">\(M=M_{i}\)</span> such that <span
class="math inline">\(L\left( M_{i} \right) =L_{d}\)</span>:</p>
<ul>
<li><p>If <span class="math inline">\(w_{i}\in L_{d},w_{i}\notin L\left(
M_{i} \right) =L_{d}\)</span>.</p></li>
<li><p>If <span class="math inline">\(w_{i}\notin L_{d}\)</span>, we
have <span class="math inline">\(w_{i}\notin L\left( M_{i} \right)
\Rightarrow w_{i}\in L_{d}\)</span>.</p></li>
</ul>
<p> ◻</p>
</div>
<div class="theorem">
<p>(Recursive complement is close) If <span
class="math inline">\(L\)</span> is recursive, so is <span
class="math inline">\(\overline{L}\)</span>.</p>
</div>
<div class="theorem">
<p>(Recursive complement to RE) If both <span
class="math inline">\(L\)</span> and <span
class="math inline">\(\overline{L}\)</span> are RE, then <span
class="math inline">\(L\)</span> is in R.</p>
</div>
<div class="proof">
<p><em>Proof.</em> (Recursive complement to RE) Let <span
class="math inline">\(L=L\left( M_{1} \right) ,\overline{L}=L\left(
M_{2} \right)\)</span>. Construct a TM with two tapes for <span
class="math inline">\(M_1\)</span> and <span
class="math inline">\(M_2\)</span> that run spiltly. If <span
class="math inline">\(M_1\)</span> accept, <span
class="math inline">\(M\)</span> accept, if <span
class="math inline">\(M_2\)</span> accept, <span
class="math inline">\(M\)</span> reject. Then <span
class="math inline">\(M\)</span> always halt. So <span
class="math inline">\(L\)</span> is in R. ◻</p>
</div>
<div class="definition">
<p>(Universal Language) <span class="math inline">\(L_{u}=\{\left( M,w
\right) \ |\ M\text{ accepts }w\}\)</span>.</p>
</div>
<div class="theorem">
<p>(Universal Language) There is a TM <span
class="math inline">\(U\)</span> such that <span
class="math inline">\(L_{u}=L\left( U \right)\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> (Universal Language) Use a 4-tape TM for input, M’s
tape, M’s state and something, then:</p>
<ol>
<li><p>Examine the validity of <span class="math inline">\(M\)</span>,
if invalid, reject.</p></li>
<li><p>Initialize the string <span class="math inline">\(w\)</span> on
the input tape.</p></li>
<li><p>Place <span class="math inline">\(0\)</span>, the starting state
of <span class="math inline">\(M\)</span> on the state tape.</p></li>
<li><p>Scan transition on the M’s tape then do transition like
M.</p></li>
<li><p>If M has no transition, U must reject.</p></li>
<li><p>If M accepts, U accept.</p></li>
</ol>
<p> ◻</p>
</div>
<div class="theorem">
<p>(Universal Language) <span class="math inline">\(L_{u}\)</span> is in
RE but not in R.</p>
</div>
<div class="proof">
<p><em>Proof.</em> (Universal Language) <span
class="math inline">\(L_{u}\)</span> in RE is proofed. Assume <span
class="math inline">\(L_{u}\)</span> is in R, then <span
class="math inline">\(\overline{L}_{u}=\{\left( M,w \right) \ |\ M\text{
not accepts }w\}\in R\)</span> Its TM can be built to accept <span
class="math inline">\(L_{d}\)</span>, which is impossible. ◻</p>
</div>
<div class="definition">
<p>(Reduction) For two problems <span class="math inline">\(P_1\)</span>
and <span class="math inline">\(P_2\)</span>, <span
class="math inline">\(P_1\)</span> reduces to <span
class="math inline">\(P_2\)</span> means there exists an algorithm
convert from instances of <span class="math inline">\(P_1\)</span> to
instances of <span class="math inline">\(P_2\)</span>.</p>
</div>
<div class="definition">
<p>(Empty Language) <span class="math inline">\(L_{e}=\{M\ |\ L\left( M
\right) =\emptyset\}\)</span>.</p>
</div>
<div class="definition">
<p>(Not Empty Language) <span class="math inline">\(L_{ne}=\{M\ |\
L\left( M \right) \ne\emptyset\}\)</span>.</p>
</div>
<div class="theorem">
<p>(Not Empty Language) <span class="math inline">\(L_{ne}\)</span> is
in RE but not recusive.</p>
</div>
<div class="proof">
<p><em>Proof.</em> (Not Empty Language) For RE, TM of <span
class="math inline">\(L_{ne}\)</span> can keep input different string
<span class="math inline">\(w\)</span> to <span
class="math inline">\(M\)</span> until accepted, if it does not halt it
also rejects. If <span class="math inline">\(L\left( M \right) \ne
\emptyset\)</span> it must halt some time.</p>
<p>For R, we can reduce <span class="math inline">\(L_{u}\)</span> to
<span class="math inline">\(L_{ne}\)</span>, since <span
class="math inline">\(L_{u}\)</span> is not in R, <span
class="math inline">\(L_{ne}\)</span> is not in R. ◻</p>
</div>
<div class="theorem">
<p>(Rice) Every non-trival property of RE is undecidable.</p>
</div>
<div class="proof">
<p><em>Proof.</em> (Rice) Let <span class="math inline">\(P\subseteq
RE\)</span> be a non-trival property <span
class="math inline">\(L_{P}=\{M_{i}\ |\ L\left( M_{i} \right) \in
P\}\)</span>. Assume <span class="math inline">\(\emptyset \notin
P\)</span>. as <span class="math inline">\(P\)</span> is non-trival,
there is a non-empty <span class="math inline">\(L=L\left( M_{L} \right)
\in P\)</span>, we can use <span class="math inline">\(M_{L}\)</span> to
build a 2-tape <span class="math inline">\(M&#39;\)</span> to reduce
<span class="math inline">\(L_{u}\)</span> to <span
class="math inline">\(L_{P}\)</span> by:</p>
<ol>
<li><p><span class="math inline">\(M&#39;\)</span> simulate <span
class="math inline">\(M\)</span> in input <span
class="math inline">\(w\)</span> (may hot halt)</p></li>
<li><p>If <span class="math inline">\(M\)</span> rejects <span
class="math inline">\(w\)</span>, <span
class="math inline">\(M&#39;\)</span> ignore input in the second
tape.</p></li>
<li><p>If <span class="math inline">\(M\)</span> accepts <span
class="math inline">\(w\)</span>, <span
class="math inline">\(M&#39;\)</span> simulaltes <span
class="math inline">\(M_{L}\)</span> on second tape input <span
class="math inline">\(x\)</span>.</p></li>
</ol>
<p>Let <span class="math inline">\(L&#39;=L\left( M&#39;
\right)\)</span>, if we can determine whether <span
class="math inline">\(L&#39;\in P\)</span>, or whether <span
class="math inline">\(L&#39;=\emptyset\)</span> which means <span
class="math inline">\(M\)</span> does not halt or rejects. Then we can
know <span class="math inline">\(M\)</span> accepts or rejects <span
class="math inline">\(w\)</span> in determine steps. That reduce <span
class="math inline">\(L_{u}\)</span> to <span
class="math inline">\(L_{P}\)</span> ◻</p>
</div>
<div class="definition">
<p>(Post’s Corespondence Problem, PCP) Given two strings lists,
determine a index list (may repeats) such that two lists join by index
is the same string.</p>
</div>
<div class="theorem">
<p>(Post’s Corespondence Problem, PCP) PCP is undecidable.</p>
</div>
<div class="proof">
<p><em>Proof.</em> (Post’s Corespondence Problem, PCP) Define Modified
PCP (MPCP) which requires the first index to be constant. We can reduce
MPCP to PCP by adding a separator <span class="math inline">\(*\)</span>
between every two letters in every strings. Then add prefix <span
class="math inline">\(*\)</span> to keep the constant start string.</p>
<p>Also we can reduce <span class="math inline">\(L_{u}\)</span> to MPCP
by construct TM ID changes in two string lists (the second list’s first
string stored the initial ID. Second is one ID ahead of the first to
make ID transitions written in two lists, also need some
separators).</p>
<p>Since <span class="math inline">\(L_{u}\)</span> is undecidable, MPCP
is undecidable, PCP is also undecidable. ◻</p>
</div>
<div class="theorem">
<p>(CFG ambiguous) CFG ambiguous is undecidable.</p>
</div>
<div class="proof">
<p><em>Proof.</em> (CFG ambiguous) Reduce PCP to CFG ambiguous problem.
Let the two lists are <span
class="math inline">\(A=[w_1,w_2,\ldots,w_{k}],B=[x_1,x_2,\ldots,x_{k}]\)</span>,
construct CFG: <span class="math display">\[\begin{aligned}
                S\rightarrow &amp; A\ |\ B\nonumber\\
                A\rightarrow &amp; w_1Aa_1\ |\ w_2Aa_2\ |\ \ldots\ |\
w_{k}Aa_{k}\ |\ w_1a_1\ |\ w_2a_2\ |\ \ldots\ |\ w_{k}a_{k}\nonumber\\
                B\rightarrow &amp; x_1Ba_1\ |\ x_2Ba_2\ |\ \ldots\ |\
x_{k}Ba_{k}\ |\ x_1a_1\ |\ x_2a_2\ |\ \ldots\ |\ x_{k}a_{k}\nonumber
            
\end{aligned}\]</span> Where <span class="math inline">\(a_{i}\)</span>
is new terminal separator. The CFG is ambiguous if PCP has a
solution. ◻</p>
</div>
<div class="theorem">
<p>(CFG features) Let <span class="math inline">\(G_1,G_2\)</span> be
CFG, R be regular expression, all follow problems are undecidable:</p>
<ul>
<li><p><span class="math inline">\(L\left( G_1 \right) \cap L\left( G_2
\right) =\emptyset\)</span></p></li>
<li><p><span class="math inline">\(L\left( G_1 \right) = L\left( G_2
\right)\)</span></p></li>
<li><p><span class="math inline">\(L\left( G_1 \right) =L\left( R
\right)\)</span></p></li>
<li><p><span class="math inline">\(L\left( G_1 \right)
=\Gamma^{*}\)</span></p></li>
<li><p><span class="math inline">\(L\left( G_1 \right) \subseteq L\left(
G_2 \right)\)</span></p></li>
<li><p><span class="math inline">\(L\left( R \right) \subseteq L\left(
G_1 \right)\)</span></p></li>
</ul>
</div>
<div class="definition">
<p>(Time complexity of a TM) For any input of length <span
class="math inline">\(n\)</span>, the number of steps the TM runs on all
possible inputs.</p>
</div>
<div class="definition">
<p>(Complexity class P) The set of languages <span
class="math inline">\(L=L\left( M \right)\)</span>. Time complexity of
<span class="math inline">\(M\)</span> <span
class="math inline">\(T\left( M \right)\)</span> is a polynomial of
<span class="math inline">\(n\)</span>.</p>
</div>
