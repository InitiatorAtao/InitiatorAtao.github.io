### RIP

RIP (Routing Information Protocal) 是内部网关协议 IGP 中最先得到广泛使用的协议,是一种**分布式的基于距离向量的路由选择协议**,其最大优点是简单.

在本题中,你需要编写一个虚拟路由器类,通过分布式的算法在由该类对象构成的一个虚拟网络中求出最短路由,其要达成的目标如下:

网络中的每个路由器维护从它自己到其他每一个路由器的路由表,其中包含距离和下一跳地址,若将网络看作一个无向图,每个路由器为一个节点,路由器间的连接为权值为 1 的无向边,其中 "距离" 即两个路由器之间的最短路长度 (到自身的距离为 0).而 "下一跳路由" 则是任意一条这样的最短路上与本路由器相邻的路由器地址.

为求解上述问题, RIP 使用的算法如下:

1. 起初,每个路由器只知道与自身相邻的一些路由器,将到这些路由器的距离设为 1,下一跳路由设为目标路由器本身.
2. 每次迭代,所有路由器向相邻的路由器发送自身的路由表,对于相邻路由器 X 发送来的路由表中的每一项,将其 "下一跳路由" 更改为 X,距离 +1,如果得到的距离小于自身路由表中对应项的距离,则替换对应项,如果自身路由表中没有对应的目标路由,则将该项添加到路由表中.

上述算法的基础是 Bellman-Ford 算法,你可能已经在离散数学等课程中对其有所了解.

具体地,你需要实现一个路由器类 `Router` ,实现初始化函数 `init(std::vector<Router*>)` ,传入相邻的路由器指针,实现初始化.以及接口 `bool receive(std::vector<Jump>)` 和 `std::vector<Jump> send()` ,实现路由表接收与分发,其中 Jump 为一个结构体,表示路由表中的一项,定义为:

```
struct Jump
{
    Router* dest,next;  //路由表中的目标路由器和下一跳路由
    int length;         //路由表中的距离
}
```

为检测网络路由更新是否收敛,你需要在 `bool receive(std::vector<Jump>)` 接口返回接收的路由表是否对本路由器的路由表产生了更新,包括添加和修改自身路由表中的项.

注意 `send` 发送的路由表需要包含发送路由器本身,距离为 0,你可以使用 `this` 指针做到这一点.同时,网络不保证所有路由器都可以访问到其他任意一个路由器,对于当前路由器无法访问的路由器,你无需在路由表中包含到其的路由.

测试保证网络大小在合理范围内,你可以使用朴素的算法计算和更新路由表而不必担心超时问题,如果你遇到了超时问题,请先检查更新接口的实现是否导致了路由更新不收敛.