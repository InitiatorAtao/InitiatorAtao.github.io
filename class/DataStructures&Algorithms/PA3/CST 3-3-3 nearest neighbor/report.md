## 算法思路和实现要点
使用 KD 树维护维护所有的点,查询时从树根开始,先使用分割点更新答案,然后在当前分割维度上比较分割点和查询点,选择包含查询点的部分递归查询,返回时如果当前最短距离大于查询点到分割超平面的距离,则向另一个部分继续递归查询.

为提高效率,根据随机数据的测试结果,每个叶子节点存储至多 75 个点的坐标,构建过程中当前子树内的点少于 75 个时则直接将其存储在线性存储池内并在叶子上保留其索引和大小信息.查询时遇到叶子节点直接遍历其内部所有的点信息更新答案.
## 渐进时间复杂度的分析，包含过程
建树过程中每次选择当前分割坐标下中位数的点进行分割,故节点数每层减半,树高度在 $O(\log n)$ 级别,构建时使用线性的中位数寻找算法,时间复杂度 $O(n\log n)$.查询时由于树高得到保证且数据随机,重复递归的次数不多,时间复杂度仍为与树高相关的 $O(\log n)$,故总时间复杂度 $O((n+q)\log n)$.
## 渐进空间复杂度的分析，包含过程
代码实现无需动态开辟空间,所需的静态空间即 KD 树构建和存储信息的 $O(n)$ 级别的空间,故渐进空间复杂度为 $O(n)$.
## 遇到的困难和解决方法
代码运行时间常数问题,根据随机数据的测试结果,每个叶子节点存储至多 75 个点的坐标可以加快极限数据规模下的效率.
## 估计完成本题所用时间 
2h
## 关于本题的更多感想
