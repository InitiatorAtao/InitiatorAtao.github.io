## 算法思路和实现要点
使用 Splay 维护代号序列,编号即从 0 开始的代号序列中的位置,无需特别维护.

插入操作即将第 $p$ 个节点拉到树根,然后新建一个树根连接原左子树,原树根和右子树整体作为新右子树.

交换位置即两个标准删除和重新插入操作,注意操作顺序即可.

非循环区间翻转,在树节点上维护一个翻转标记,需要翻转区间时通过一到两次 Splay 操作构建出一个代表该区间的子树,在子树根上打标记返回.所有操作前先检查标记,如有标记则交换左右子树并给子树打上标记再清除当前节点标记.

旋转,等效于重新选择一个人作为起始位置,设这个人的位置为 $p$,这又等效于翻转 $[1,p-1],[p,n]$,再翻转 $[1,n]$.

循环区间翻转,选择区间左端点的人作为起始后转换为非循环区间翻转.
## 渐进时间复杂度的分析，包含过程
插入,交换位置都基于基本树操作,均摊时间复杂度 $O(\log n)$.

非循环区间翻转基于常数次 Splay 以及常数复杂度的标记操作,标记对所有操作增加等同于操作自身复杂度的下传消耗,不影响整体复杂度,故单次操作复杂度 $O(\log n)$.

旋转操作基于三次非循环区间翻转,复杂度 $O(\log n)$.

循环区间翻转基于一次旋转和一次非循环区间翻转,复杂度 $O(\log n)$.
## 渐进空间复杂度的分析，包含过程
只需 Splay 的增删空间,在添加删除节点回收池的情况下可以做到 $O(n)$ 即维护队形的空间.
## 遇到的困难和解决方法
旋转以及循环区间翻转的实现,为了维持简单的树结构和操作方式,需要对操作进行逐步的分析,等效和拆解,使用简单操作构建出等效的复杂操作.
## 估计完成本题所用时间 
3h
## 关于本题的更多感想
