## DSA LAB3 Report

### 数据生成器

数据生成器代码为提交包中的 `data_generator.cpp`,接收两个必选参数和两个可选参数,从左到右表示插入数量,查询数量,查询范围 (超出插入数量的部分生成失败查询), 是否混合插入和查询.三个数据生成时的参数如下:

```
data 1 200000 200000 250000
data 2 100000 300000 250000
data 3 200000 200000 150000 true
```

### 哈希策略实现

"坏" 哈希函数:直接将字符串所有字符 ASCII 整数求和,对表长取模即可:

$$
\operatorname{hash}(s)=(\sum_{i=0}^{l_{s}}\operatorname{ord}(s_{i})) \operatorname{mod} l
$$

"好" 哈希函数:将字符串按顺序进行 ASCII 加权求和:

$$
\operatorname{hash}(s)=(\sum_{i=0}^{l_{s}} p^{i}\operatorname{ord}(s_{i})) \operatorname{mod} l
$$

双向平方试探策略:在结构体中记录一个初始哈希位置 `hash_key`, 在 `init` 被调用时将其置为 `-1`,初次调用 `operator()` 时记录下初始哈希位置,以便后续通过初始哈希位置和上一次探测位置计算出下一次探测位置.

公共溢出区策略:不改动框架接口,公共溢出区和哈希区共用哈希表,在结构体中记录一个启动标记 `start`,初始化时将其置为 `true`,在 `operator()` 被调用时,如果启动标志被设置则返回哈希表首部地址 `0`,否则返回线性探测 `(last_choice+1)%table_size`.

### 测试数据构造方法

对于前两个数据,查询操作均位于插入操作之后,从 `poj.txt` 读入数据后使用 `std::shuffle` 将其随机打乱,直接插入前 `insert_number` 个元素.查询时随机生成 `[1,query]` 之间的随机数 `i`,查询打乱后的第 `i` 个元素.其中第一个数据的插入和查询数量相等,第二个数据查询操作数量是插入操作的三倍,查询均有约 $25\%$的概率失败.

对于第三个数据,先生成对应数量的插入和查询操作,随机打乱后线性扫描,遇到插入操作则从前往后插入打乱后的输入元素,遇到查询操作则与之前相同随机生成.

得到的结果如下,其中 "坏" 哈希函数所需运行时间均超过 60 秒,不再记录具体时间.

||data 1|data 2|data 3|
|-|-|-|-|
|线性试探策略|0.453|0.459|0.481|
|双向平方试探策略|0.451|0.471|0.503|
|公共溢出区策略|13.125|2.609|8.200|

### 实验结果分析

1. "好" 哈希函数的效率远高于 "坏" 哈希函数,因为不均匀分布的哈希映射会在映射密集处产生大量的冲突,使效率退化到 $O(n^2)$ 级别.

2. 线性试探和双向平方试探的性能相差不大,在插入任务较重时双向平方的效率较高,其他情况线性试探的效率较高.因为线性试探可以更有效的利用内存访问的空间局部性和时间局部性,但是会产生更严重的冲突,所以其在一般应用时效率较高,但插入操作过多时效率不如冲突解决更好的双向平方试探.

3. 封闭散列占明显优势,开放散列在数据量较大或不确定,以及可以提供额外的动态分配空间的情况下比较适用.

4. 非均匀分布的数据可能造成更多的冲突,哈希分布不均等,从而降低查找效率,造成性能瓶颈.

5. 动态扩容缩容建议使用可动态分配空间的开放散列,每个哈希桶维护一个链表,对于一般的容量变化可以通过链表长度的变化进行容纳,当哈希表容量到达一定阈值时,直接选取一定倍长的新表长重构整个表,以达到均摊常数级别的复杂度.
